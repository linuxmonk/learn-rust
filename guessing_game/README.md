## Guessing Game

A program that asks user to guess a number between 1 - 100. The program then tells the user if the guess is lesser / greater than the number generated by the computer; Until the correct answer is guessed.

```
use std::io
```

Imports the IO library from the standard library.

By default, Rust brings only a few types into scope that every program needs (these don't need to be imported explicitly). This is called [_the prelude_](https://doc.rust-lang.org/std/prelude/index.html).

```
println!()
```

Prints to stdout via the macro `println`.

```
let mut guess = String::new()
```

*NOTE* The above line has type inference. The type of `guess` is `String` type.

`let` lets you declare an identifier. By default the identifier declared is *immutable*. To make it mutable we say `let mut guess`. The `guess` is bound to a new string returned by `String::new()`.

* `io::stdin()` - `stdin()` is a *associated function* (a.k.a static function in other languages). called via the scope resolution op (`::`).
* `stdin()` returns instance of `std::io::Stdin` type. Which has a method `read_line`. `read_line` accepts (`&mut guess`). 
* By default references in Rust are also immutable. For `read_line` to be able to write into a memory location of `guess` it must be mutable. So we pass `&mut guess`.
* Error handling with *`Result`* type. The `read_line` returns `io::Result` type. Rust has number of `Result` types in its standard library. A generic `Result` as well as specific ones in submodules such as `io::Result`.
* `Result` types are enumerations (a.k.a enums). For Result the variants are `Ok` and `Err`. The `.except` returns back the result as-is if there was it was not `Err` and would crash the program if the `Result` was an `Err` variant.

## Generating the random number

Next to generate a random number we need to use a crate (external library) in Rust. The `rand crate` needs to be added as a dependency to the `Cargo.toml` dependencies section.

```
# Cargo.toml

[dependencies]
rand = "0.5.5"
```

This adds the dependency of `rand` crate. Cargo understands semver. The above means any library that is atleast 0.5.5 but < 0.6.0.

### Automatically update patch versions of a library

To automatically look for and update patch versions of a library/crate. Do -

```
cargo update
```

### Running Cargo Build

Running `cargo build` after updating the depdencies would download the same and compile it as shown -

```
➜  guessing_game git:(main) ✗ cargo build
    Updating crates.io index
  Downloaded rand_core v0.3.1
  Downloaded rand_core v0.4.2
  Downloaded libc v0.2.91
  Downloaded rand v0.5.6
  Downloaded 4 crates (694.7 KB) in 4.60s
   Compiling libc v0.2.91
   Compiling rand_core v0.4.2
   Compiling rand_core v0.3.1
   Compiling rand v0.5.6
   Compiling guessing_game v0.1.0 (/Users/sai/src/learn-rust/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 4m 30s
```

If a new version of the `rand` crate is released say `0.5.6` that has a fix that breaks your code ? That's where *`cargo.lock`* comes in. `Cargo.lock` provides you with a reproducible build system. When you build your program `Cargo.lock` is generated which computes the versions of all the dependencies and stores it there. Like -

```
# cargo.lock
[[package]]
name = "libc"
version = "0.2.91"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8916b1f6ca17130ec6568feccee27c156ad12037880833a3b842a823236502e7"
```

On the subsequent builds Rust only refers to *Cargo.lock* and not Cargo.toml every time.

## Generate a random number

```
use rand::Rng;
```

This imports a `Rng` trait. The trait defines the methods random number generators implement.

The `rand::thread_rng()` gives a random number generator that is local to thread and seeded by the operating system. On that we call `gen_range()`.

## Comparing the secret number with the guessed value

Just like `io::Result` we use `cmp::Ordering` enum. For comparison. For that we import `std::cmp::Ordering`.

The `match` expression has arms. Each arm has a pattern and a block of code. The match expression is compared to the pattern. If there is a match then the block of code is executed. In the example below -

```
    match guess.cmp(&secret_number) {
        Ordering::Less => println!("Too small"),
        Ordering::Greater => println!("Too big"),
        Ordering::Equal => println!("You win!"),
    }
```

The above code throws an error because `guess` is a String type due to type inference and secret_number is an int. By default in Rust the default integer is i32. There are others like u32, i64, u64.

To convert `guess` to `i32` we do -

```
let guess: u32 = guess.trim().parse().expect("Please input a number");
```

Here we define a variable `guess` of type `u32`. 

### Shadowing

In Rust there is a concept of shadowing where we can use the same variable to hold a value of different type. That way we prevent declaring variables like guess_str and guess etc. The above is shadowing syntax. `guess` is shadowed to contain a `u32` value.



